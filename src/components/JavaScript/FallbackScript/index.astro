---
---

<script>
	type FormElement = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement

	const VALIDITIES = [
		"badInput",
		"customError",
		"patternMismatch",
		"rangeOverflow",
		"rangeUnderflow",
		"stepMismatch",
		"tooLong",
		"tooShort",
		"typeMismatch",
		"valueMissing",
	]

	const VALIDATABLES = ["INPUT", "SELECT", "TEXTAREA"]
	const VALIDATABLE_INPUT_TYPES = [
		"checkbox",
		"color",
		"date",
		"datetime-local",
		"email",
		"file",
		"month",
		"number",
		"password",
		"radio",
		"range",
		"search",
		"tel",
		"text",
		"time",
		"url",
		"week",
	]

	const errorFormatter = new Intl.ListFormat("en", {
		style: "long",
		type: "conjunction",
	})

	const forms = [...document.querySelectorAll("form")]

	forms.forEach((form) => {
		form.setAttribute("novalidate", "")
	})

	function isValidatable(element: Element) {
		return (
			VALIDATABLES.includes(element.tagName) &&
			(element.tagName !== "INPUT" ||
				VALIDATABLE_INPUT_TYPES.includes((element as HTMLInputElement).type)) &&
			!("novalidate" in (element as HTMLElement).dataset)
		)
	}

	function valueMissing(element: FormElement) {
		const type =
			(element.tagName === "INPUT" && element.type) ||
			(element.tagName === "SELECT" && "select") ||
			(element.tagName === "TEXTAREA" && "text")

		switch (type) {
			case "email":
				return " must be an email address."
			case "tel":
				return " must include your telephone number."
			case "select":
				return ": needs a selection."
			default:
				return " needs some input here."
		}
	}

	function setHelp(element: FormElement) {
		const field = element.parentNode?.parentNode
		const help = field?.querySelector(".sb-help")

		const errors = VALIDITIES.filter((validity) => {
			const v = validity as keyof ValidityState
			return element.validity[v]
		})
			.map((validity) => {
				switch (validity) {
					case "valueMissing":
						return valueMissing(element)
					case "badInput":
						return " looks wrong"
					case "patternMismatch":
						return " doesn&rsquo;t match the expected pattern"
					case "rangeOverflow":
						return ` must not be more than ${element.getAttribute("max")}`
					case "rangeUnderflow":
						return ` must be at least ${element.getAttribute("min")}`
					case "stepMismatch":
						return ` must be evenly divisible by ${element.getAttribute(
							"step"
						)}`
					case "tooLong":
						return ` mustn't be longer than ${element.getAttribute(
							"maxlength"
						)} characters`
					case "tooShort":
						return ` must be at least ${element.getAttribute(
							"minlength"
						)} characters`
					case "typeMismatch":
						return ` must be a valid ${element
							.getAttribute("type")
							?.replace(/email/, "email address")}`
					default:
						return ""
				}
			})
			.filter((v) => v)

		if (help && errors.length) {
			element.setCustomValidity("")
			help.replaceChildren(`This field ${errorFormatter.format(errors)}`)
			help.classList.remove("sb-help-valid")
			help.classList.add("sb-help-invalid")
		}

		return `This field ${errorFormatter.format(errors)}`
	}

	function validateFields(form: HTMLFormElement) {
		return (
			[...(form.elements as HTMLFormControlsCollection)].filter(
				isValidatable
			) as Array<FormElement>
		).forEach((element) => setHelp(element))
	}

	function setTouched(element: FormElement) {
		if (isValidatable(element)) {
			element.classList.add("sb-touched")
		}
	}

	function setDirty(element: FormElement) {
		if (isValidatable(element)) {
			if ("defaultValue" in element && element.value !== element.defaultValue) {
				element.classList.add("sb-dirty")
			} else {
				element.classList.remove("sb-dirty")
			}
		}
	}

	console.log("« Fallback validation enabled. »")

	// globalThis._sitebender.

	// globalThis.addEventListener("DOMContentLoaded", function () {

	// 	globalThis.document.addEventListener("submit", function (event) {
	// 		event.preventDefault()

	// 		const target = event.target
	// 		const action = target.action

	// 		if (target.reportValidity()) {
	// 			const formData = new FormData(target)
	// 			const body = JSON.stringify(
	// 				[...formData.entries()].reduce((acc, [key, value]) => {
	// 					const val = acc[key] ? `${acc[key]},${value}` : value

	// 					return {
	// 						...acc,
	// 						[key]: val,
	// 					}
	// 				}, {}),
	// 				null,
	// 				2
	// 			)
	// 		} else {
	// 			validateFields(target)
	// 		}
	// 	})

	// 	globalThis.document.addEventListener("focusin", function ({ target }) {
	// 		if (isValidatable(target)) {
	// 			setTouched(target)
	// 			setDirty(target)
	// 		}
	// 	})

	// 	globalThis.document.addEventListener("focusout", function ({ target }) {
	// 		if (isValidatable(target)) {
	// 			setDirty(target)
	// 			setHelp(target)
	// 		}
	// 	})
	// })
</script>
